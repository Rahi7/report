{
  "language": "Solidity",
  "sources": {
    "contracts/Medlock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.8;\n\nerror NotOwner();\nerror NotDoctor();\nerror NotPatient();\n\ncontract Medlock {\n    address public owner;\n\n    uint256 public nextHospitalId = 1;\n    uint256 public nextPrescriptionId = 1;\n    uint256 public nextPatientId = 1;\n    uint256 public nextDoctorId = 1;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner() {\n        if (msg.sender != owner) revert NotOwner();\n        _;\n    }\n\n    modifier onlyDoctor() {\n        string memory license = doctorLicenses[msg.sender];\n        if (bytes(license).length == 0) revert NotDoctor();\n        _;\n    }\n\n    modifier onlyPatient(string memory aadhaar) {\n        if (aadhaarToAddress[aadhaar] != msg.sender) revert NotPatient();\n        _;\n    }\n\n    struct Hospital {\n        uint256 hospitalId;\n        string name;\n        bool isRegistered;\n    }\n\n    struct Doctor {\n        string doctorId;\n        string licenseNumber;\n        string name;\n        string specialization;\n        uint256 hospitalId;\n    }\n\n    struct Patient {\n        string patientId;\n        string aadhaar;\n        string name;\n        string dob;\n        string contactDetails;\n    }\n\n    struct Prescription {\n        uint256 prescriptionId;\n        string patientId;\n        string doctorId;\n        string issueDate;\n        string diagnosis;\n        string treatment;\n        string remarks;\n    }\n\n    mapping(address => Hospital) public hospitals;\n    mapping(uint256 => address) public hospitalById;\n\n    mapping(address => string) public doctorLicenses;\n    mapping(string => Doctor) public doctors; // license => Doctor\n    mapping(string => string) public licenseToDoctorId;\n\n    mapping(address => string) public patientAadhaars;\n    mapping(string => address) public aadhaarToAddress;\n    mapping(string => Patient) public patients; // aadhaar => Patient\n    mapping(string => string) public aadhaarToPatientId;\n\n    mapping(string => Prescription[]) public prescriptions; // patientId => list of prescriptions\n\n    function registerHospital(address _hospitalAddress, string memory _name) public onlyOwner {\n        require(!hospitals[_hospitalAddress].isRegistered, \"Already registered\");\n\n        hospitals[_hospitalAddress] = Hospital(nextHospitalId, _name, true);\n        hospitalById[nextHospitalId] = _hospitalAddress;\n        nextHospitalId++;\n    }\n\n    function registerDoctor(\n        address _wallet,\n        string memory _licenseNumber,\n        string memory _name,\n        string memory _specialization,\n        uint256 _hospitalId\n    ) public onlyOwner {\n        require(bytes(doctorLicenses[_wallet]).length == 0, \"Doctor already registered\");\n        require(bytes(doctors[_licenseNumber].doctorId).length == 0, \"License number already registered\");\n\n        doctorLicenses[_wallet] = _licenseNumber;\n\n        string memory doctorId = generateDoctorId(nextDoctorId++);\n        licenseToDoctorId[_licenseNumber] = doctorId;\n\n        doctors[_licenseNumber] = Doctor(doctorId, _licenseNumber, _name, _specialization, _hospitalId);\n    }\n\n    function registerPatient(\n        address _wallet,\n        string memory _aadhaar,\n        string memory _name,\n        string memory _dob,\n        string memory _contactDetails\n    ) public onlyOwner {\n        require(aadhaarToAddress[_aadhaar] == address(0), \"Aadhaar already registered\");\n        require(bytes(patientAadhaars[_wallet]).length == 0, \"Wallet already used\");\n\n        patientAadhaars[_wallet] = _aadhaar;\n        aadhaarToAddress[_aadhaar] = _wallet;\n\n        string memory patientId = generatePatientId(nextPatientId++);\n        aadhaarToPatientId[_aadhaar] = patientId;\n\n        patients[_aadhaar] = Patient(patientId, _aadhaar, _name, _dob, _contactDetails);\n    }\n\n    function addPrescription(\n        string memory _aadhaar,\n        string memory _diagnosis,\n        string memory _treatment,\n        string memory _remarks\n    ) public onlyDoctor {\n        string memory license = doctorLicenses[msg.sender];\n        string memory doctorId = licenseToDoctorId[license];\n        require(aadhaarToAddress[_aadhaar] != address(0), \"Patient not registered\");\n\n        string memory patientId = aadhaarToPatientId[_aadhaar];\n        string memory issueDate = uintToString(block.timestamp);\n\n        prescriptions[patientId].push(\n            Prescription(\n                nextPrescriptionId++,\n                patientId,\n                doctorId,\n                issueDate,\n                _diagnosis,\n                _treatment,\n                _remarks\n            )\n        );\n    }\n\n    function getMyProfile() public view returns (\n        string memory patientId,\n        string memory name,\n        string memory dob,\n        string memory contactDetails\n    ) {\n        string memory aadhaar = patientAadhaars[msg.sender];\n        require(bytes(aadhaar).length > 0, \"Not registered\");\n\n        Patient memory p = patients[aadhaar];\n        return (p.patientId, p.name, p.dob, p.contactDetails);\n    }\n\n    function getMyPrescriptions() public view returns (Prescription[] memory) {\n        string memory aadhaar = patientAadhaars[msg.sender];\n        require(bytes(aadhaar).length > 0, \"Not registered\");\n\n        string memory patientId = aadhaarToPatientId[aadhaar];\n        return prescriptions[patientId];\n    }\n\n    function isHospitalRegistered(address _hospitalAddress) public view returns (bool) {\n    return hospitals[_hospitalAddress].isRegistered;\n    }\n\nfunction isDoctorRegistered(address _wallet) public view returns (bool) {\n    return bytes(doctorLicenses[_wallet]).length != 0;\n}\n\nfunction isPatientRegistered(string memory _aadhaar) public view returns (bool) {\n    return aadhaarToAddress[_aadhaar] != address(0);\n}\n\n\n    function uintToString(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) return \"0\";\n        uint256 temp = _i;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (_i != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(_i % 10)));\n            _i /= 10;\n        }\n        return string(buffer);\n    }\n\n    function generatePatientId(uint256 _id) internal pure returns (string memory) {\n        if (_id < 10) return string(abi.encodePacked(\"P00\", uintToString(_id)));\n        if (_id < 100) return string(abi.encodePacked(\"P0\", uintToString(_id)));\n        return string(abi.encodePacked(\"P\", uintToString(_id)));\n    }\n\n    function generateDoctorId(uint256 _id) internal pure returns (string memory) {\n        if (_id < 10) return string(abi.encodePacked(\"D00\", uintToString(_id)));\n        if (_id < 100) return string(abi.encodePacked(\"D0\", uintToString(_id)));\n        return string(abi.encodePacked(\"D\", uintToString(_id)));\n    }\n}\n"
    }
  },
  "settings": {
    "evmVersion": "paris",
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}